---
layout: post
title: "js revisit"
date: 2016-07-25 19:24:15
comments: true
published: true
description: "JS, Basic"
keywords: "JS"
excerpt_separator: <!--more-->
categories: web
tags: 
- web
---

The notes will first follow the content from the standard book: Javascript - the definite guide (6th edition), and will highlight some basic ideas behind it. These highlights will be displayed by forms of notes.
<!--more-->

# Javascript Revisit

The notes will first follow the content from the standard book: Javascript - the definite guide (6th edition), and will highlight some basic ideas behind it. These highlights will be displayed by forms of notes.

## Core Concepts

*1. 

Add semi-colon or not? - As long as the maximum of valid code is not misinterpretated. line break is usually viewed as non-semilicon as much as possible. 

Some execptions: `return`, `++`, `--`

*2.

JS have two primitive types: numbers and strings. Others are object types, where a special object `array` is included. There are some predefined operations for `array`. Also, `function` is another special kind of object. 

*3

For numbers, note the difference between `inf`, `-inf` and `NaN` (and how they are generated, `isNaN()` and `isFinite()` are different in what way?). For floating points, note about rounding errors. Floating points are offered some conversion functions: `toFixed()`

Also, `Math` offers several useful APIs for number manipulation.

A special kind of number is `Date()`, it has several useful APIs like `Date(2016,7,25).getMonth()`.

*4

For strings, note about several predefined APIs: `slice(-3)`, `indexOf("l", 3)`, `lastIndexOf("l")`, `split(".")`, `replace("h", "H")`

*5

`var a = []; var b = a;` passes the reference of `a` to `b`. If further values are modified (e.g. `b[0] = 1`), they are both changed.

*6

For value conversion, note that `undefined != false`, only `0 == false`. Some implicit type conversion: `!!x`, `x+''`, `+x`... 

*7

Variable Hoisting: the variable in js is `function scope` instead of `block scope`, i.e, all variables in function are first hoisted at the top of the function.

*8

Expressions: note about some interesting ones:

Arithmatic: `"1"+"2"*"3" = "16"`

Relational: `"11" > "3"`, `"11" < 3`, `var a = [1]; "0" in a; 1 not in a;`

Logical: short circuit for `&&` and `||`: `a == b && stop()` act like `if`; in function(p): `p = p || {}` assigned values.

Others: `a = p ? p : "";`

*9

Statements.

`switch` statement is supported. Note about `break` for each case, also `case: a` is evaluated through `===`.

`for i in obj` is supported. but it only enumerates on keys! A big difference from python.

`'labelname: statement'` assigned a tag to this block, then you can use `break labelname` or `continue: labelname` to jump to certain block!

`try {} catch(e) {}` catches possible errors and handle them. The error can be generated by system or manually defined `throw: new Error()`.

*10

Object = set of properties + object_attributes

Property = name + value + property_attributes

Property_attributes = ["writable", "enumerable", "configurable"]

Object_attributes = ["prototype", "class", "extensible"]

prototypes can form a chain.

Inherited property can be tested as well with `'property' in o`, but not in `o.hasOwnProperty()` and `propertyIsEnumerable()`

Object can be created using: `{}`, `new Object()` and `Object.create(o)` where o can be inherited by one.

Properties can be deleted using `delete o.p`

*11

Object in ECMAScript5 also have `getter` and `setter`, whose use is to display value using different calculation and for sanity checking.

*12

Using `getOwnPropertyDescriptor()` can get one's own property with detail, such as writable. `Object.defineProperty(o, "x", { writable: false });` defined such a property.

*13

For JSON strings, `JSON.stringify(s)` and `JSON.parse()` are built-in helpful api.

*14

Array.

It's a built-in object, but implemented efficiently to be indexed faster.

It can be assigned with skipped value. `var a = []; a[100] = 1; a.length == 100`

`a[1.2] = 1` can be viewed as another property: `a["1.2"]`

*15

Note about add and delete in array: `push()`, `unshift(n1, ..)` for add, `pop()` and `shift()` for delete. `splice()` for general ones.

`a.join(" ")` to string, inverse of `s.split()`. `a.reverse()`; `a.sort()`; `a.concat(a1, a2, ...)`; `a.slice(start, len)`; `a.splice()`

In ECMAScript5, we have new functions like: 

`a.forEach(function(x, i, a) {})`; 

`a.map(function(x, i, a) {})`; 

`a.filter(function(x, i, a) {})`; 

`a.every()`/`a.some()` returns boolean value; 

`a.indexOf()`; 

`a.reduce(func)` where func get two arugments: previous result and next element. Note that object has this function as well. `o = {"x", "y", "z"} o.reduce(union)`.

*16

Array-like things.

Objects may have similar attributes like `length`, e.g., DOM objects!

ECMAScript5 defined string as array-like. Generic functions can be used like `Array.prototype.join.call("java", " ")`. Note that immutable strings cannot be applied with `pop`, `push` ...

*17

Functions.

Functions can be invoked through 4 ways: pure function; as method; as constructor; indirect `call` and `apply`.

Object.property = function f() carries a `this` object. But pure functions do not have it! 

*18

Function parameters can be `undefined` (optional ones). To allow variable length arguments, simply use `function max(...) {}`.

*19

Note that function is a special type of object, which means it can have properties. We can thus define a state-enabled function-like object! (e.g. auto-increment function or cached result for recursion.)

*20

Closure.

Remember js is lexical scoped! 
An auto-incrementor: `var uniqueInteger = (function() { var counter = 0; return function() { return counter++; }; }());`

Using `getter` and `setter`, we can future make a object, with its property self-incrementing!

Note that in order to define a list of functions using `for (i ..)`, the closure property may lead to sharing the same value between seemingly different functions!

A question: will it cause uncleaned garbage collector?

*21

Difference between `call`, `apply` and `bind`

`f.call(o, arg1, arg2, ..)` = `f.apply(o, [arg1, arg2, ..])` = o.f()

`g = f.bind(o)` -> `g(x) = o.f(x)` (temperarily add f as a property of o, so that f can use `this` as o within the function!) `bind()` can be used to do context binding for later use.

In ECMAScript5, `bind()` can be used for partical assignment of value.

## Client-side JS

*22

`async` and `defer` attributes in `<src>`

They are supportted in modern browsers, normally js scripts are executed in order they appear in html doc. If there are document follows js code, they would not be rendered after js is executed. The  `defer` attribute causes the browser to defer execution of the script until after the document has been loaded and parsed and is ready to be manipulated. The `async` attribute causes the browser to run the script as soon as possible but not to block document parsing while the script is being downloaded.

Note that `async` scripts may not be executed in the order they present, which might suffer from unsuporrtive libs. 

*23 

Client-side Javascript Timeline

> Browser creates a Document object, parsing the web and adding elements to it. document.readyState = loading

> Scripts without `defer` or `async` are executed immediately. `async` scripts are downloaded immediately, and executed as soon as possible.

> Documents are parsed. document.readyState = interactive

> `defer` scripts are executed.

> DOMContentLoaded event fired. Note that there might still be async scripts unexecuted, as well as images...

> When all resources are loaded, documents.readyState = complete.

> Event handlers working now :)

*24

Same-origin Policy

To prevent js scripts from loading and manipulating arbitary resources on web, browsers implement this restriction. Specifically, a script can read only the properties of windows and documents that have the same origin as the document that contains the script. The `origin` of a script is defined by its protocol (http or https), its host and port. 

Suppose host B loads a script from host A by `<src>` tag, then the origin of the script is host B. And it's unable to access to another script loaded from host A! XMLHttpRequest is one of this situation. (Imagine your web app loads a resource from local json file using ajax?)

To release the constraint a little, the `domain` and `origin` value of header can be set. 


*25

Cross-site scripting (XSS)

Imagine an attacker inputs a `<script src="evil.js">` into the normal user's input form, and you do not check its sanity at back-end, this script would be executed! To prevent this issue, you'd better check the sanity of users' input.

*26

The Window Object

Several default function of window: `setTimeout(func, ms)`, `setInterval`, `clearInterval`. Note about placing a `0` in ms, it will be invoked async.

`window.location === document.location === location`. It's a object, containing a `href` property storing the url. It also includes host, pathname, search and hash. `search` displays the part starting with `?`. `hash` for `#` instead. To redirect the window, simply use `location = ""`. or only redirect specific part: `location.search = "?page=2"`, `location="page2.html"`

`(window.)history.go(1) = .forward().` `.go(-1) = .back()`. For those dynamically loaded pages, H5 standardized some methods...

`(window.)screen` includes `height` and `availHeight`, where the latter one excludes the desktop bar.

Note that each `frame` has its own window object, but can access the `parent` window.

*27

Document Object Model (DOM)

A general pic for different node types: 

![]({{site.url}}/images/DOM.png)

Note that the textNode and HTML element are seperated. Different HTML elements may have specific attributes with them. 


*28

Selecting DOM Elements

Selecting elements by names and id may be done implicitly: `document.ele_id`, this can only be done if no global variables are defined with this name. But of course we recommend using `getElementById()`. `getElementsByTagName()` returns a NodeList, which is a *live reference! It will dynamically change if you manipulate the document. A powerful selector: `querySelectorAll()`, which takes in css selectors. 

*29

Traversing DOM Elements

Traversing through elements. For each element, it has methods like `parentNode`, `childNodes`, `first\lastChild`, `next\previousSibling`. `nodeType` describes the kind of node (you can refer to web for detail value.), `nodeValue` gets the textual content of a *Text node. If you want to skip the textNodes, use `firstElementChild`, `nextElementSibling`, `childElementCount`.

The HTML attributes (like `name`, `checked`) can be accessed by `e.name`, the value depends on actual type. Those non-HTML attributes (like `width`) can be accessed by `getAttribute('width')` or `setAttribute('width', '')`. These values would all be strings. H5 defines a standard way to attach additional data to elements: `data-x-max=5` can be accessed by `e.dataset.xMax`! That's awesome!

*30

Get the Content of an Element

The content of an element can have three point of view! 

Firstly, HTML text, accessed by `e.innerHTML`, you can also manipulate by another function `insertAdjacentHTML(place, text)`, see below:

![]({{site.url}}/images/insertAdjacentHTML.png)

Secondly, plain text, accessed by `e.textContent`. Texts in scripts can be accessed by 	`e.text`.

Last one, text nodes. 

*31

Manipulating Elements

Create: `createTextNode\Element\DocumentFragment` or `cloneNode(deep=False/True)`

Insert: `appendChild` to last one, can be used for reranking. `e2.parentNode.insertBefore(e1, e2)`: insert e1 before e2. 

Remove: `removeChild()`; Replace: `e2.parentNode.replaceChild(e1, e2)`

Note about `createDocumentFragment`, it standalone means nothing, but you can fill nodeList in it. When we append the fragment to another element, its children are appended instead.

*32

Get Element Geometry Stats

First to note about *document coordinate* and *viewpoint coordinate*. They differ by a scroll length. `document.body.scrollLeft\Top` / `window.pageXOffset` get the scroll stats. `clientWidth/Height` get the viewpoint size. `offsetWidth` returns the on screen size of element. `offsetLeft` returns the *relative* offset of its parent. Looping over it returns the document coo.  `getBoundingClientRect` returns the viewpoint coo. 

